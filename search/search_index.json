{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction The OCIBuilder is a tool for producing oci compliant images. This repository contains all the documentation for getting started and configuring the OCI Builder. Quick Start You can get started with the OCI Builder by following the quickstart guide . Commands Documentation of the cli commands for OCI Builder can be found here Specification A complete documentation of the entire OCI Builder specification file ocibuilder.yaml can be found here Examples Some specification examples are available here Features Features offered by the OCI Builder are documented here Repositories The ocibuilder project is available on GitHub with our ocictl images available on Dockerhub","title":"Introduction"},{"location":"#introduction","text":"The OCIBuilder is a tool for producing oci compliant images. This repository contains all the documentation for getting started and configuring the OCI Builder.","title":"Introduction"},{"location":"#quick-start","text":"You can get started with the OCI Builder by following the quickstart guide .","title":"Quick Start"},{"location":"#commands","text":"Documentation of the cli commands for OCI Builder can be found here","title":"Commands"},{"location":"#specification","text":"A complete documentation of the entire OCI Builder specification file ocibuilder.yaml can be found here","title":"Specification"},{"location":"#examples","text":"Some specification examples are available here","title":"Examples"},{"location":"#features","text":"Features offered by the OCI Builder are documented here","title":"Features"},{"location":"#repositories","text":"The ocibuilder project is available on GitHub with our ocictl images available on Dockerhub","title":"Repositories"},{"location":"installation/","text":"Installation Binary downloads of the ocictl are available on the Releases page . You can use the install.sh script to install the latest version of ocictl : curl https://raw.githubusercontent.com/ocibuilder/ocibuilder/master/install.sh | sh This requires GOPATH to be set, with bin added to your PATH . The latest images with Buildah and Docker pre-installed alongside the ocictl is available on our Dockerhub repository . To pull the latest image run the following command: docker pull ocibuilder/ocictl:latest","title":"Installation"},{"location":"installation/#installation","text":"Binary downloads of the ocictl are available on the Releases page . You can use the install.sh script to install the latest version of ocictl : curl https://raw.githubusercontent.com/ocibuilder/ocibuilder/master/install.sh | sh This requires GOPATH to be set, with bin added to your PATH . The latest images with Buildah and Docker pre-installed alongside the ocictl is available on our Dockerhub repository . To pull the latest image run the following command: docker pull ocibuilder/ocictl:latest","title":"Installation"},{"location":"quickstart/","text":"Quickstart Guide This guide covers how you can quickly get started using OCI builder. Prerequisites The prerequisites for running ocibuilder are as standard If running ocictl as standalone: 1. Have a docker installed and the docker daemon running and/or 2. Have buildah installed and available in $PATH Alternatively, if you're using the ocictl image you will have both Docker and Buildah installed by default but with the following consideration: You must run the image in an environment which supports Docker in Docker is using Docker as a builder. Install Docker Docker can be easily installed by following the instructions for the installation of Docker Desktop Install Buildah Buildah can be installed for a number of different linux distributions and instructions are available here Install ocictl You can use the install.sh script to install the latest version of ocictl : curl https://raw.githubusercontent.com/ocibuilder/ocibuilder/master/install.sh | sh This requires GOPATH to be set, with bin added to your PATH . Alternatively, you can pull the latest image with Buildah and Docker pre-installed alongside the ocictl is available on our Dockerhub repository . To pull the latest image run the following command: docker pull ocibuilder/ocictl:latest More details are available on the ocictl installation guide Generating Template Spec Once you have ocictl installed and available in the path, you can now put together your desired build specification. The quickest way to get a sample spec within your project is to run: ocictl init This will generate a template specification for you which you can then fill in with your custom build specifications. Our specification docs outline in detail how to tailor your specification to your specific build. Running a Build Once you have configured your build specification to your project you can conduct a build by running: ocictl build This will conduct a docker build be default with your given specification. By default your build context path will be treated as the current directory. If you want to run the build using buildah as the build tool, you can: In your specification, set the daemon field to false Run the following command instead: ocictl build --builder buildah Pushing your built image Once your image has been built you can very easily push it with the following command ocictl push","title":"Quickstart Guide"},{"location":"quickstart/#quickstart-guide","text":"This guide covers how you can quickly get started using OCI builder.","title":"Quickstart Guide"},{"location":"quickstart/#prerequisites","text":"The prerequisites for running ocibuilder are as standard If running ocictl as standalone: 1. Have a docker installed and the docker daemon running and/or 2. Have buildah installed and available in $PATH Alternatively, if you're using the ocictl image you will have both Docker and Buildah installed by default but with the following consideration: You must run the image in an environment which supports Docker in Docker is using Docker as a builder.","title":"Prerequisites"},{"location":"quickstart/#install-docker","text":"Docker can be easily installed by following the instructions for the installation of Docker Desktop","title":"Install Docker"},{"location":"quickstart/#install-buildah","text":"Buildah can be installed for a number of different linux distributions and instructions are available here","title":"Install Buildah"},{"location":"quickstart/#install-ocictl","text":"You can use the install.sh script to install the latest version of ocictl : curl https://raw.githubusercontent.com/ocibuilder/ocibuilder/master/install.sh | sh This requires GOPATH to be set, with bin added to your PATH . Alternatively, you can pull the latest image with Buildah and Docker pre-installed alongside the ocictl is available on our Dockerhub repository . To pull the latest image run the following command: docker pull ocibuilder/ocictl:latest More details are available on the ocictl installation guide","title":"Install ocictl"},{"location":"quickstart/#generating-template-spec","text":"Once you have ocictl installed and available in the path, you can now put together your desired build specification. The quickest way to get a sample spec within your project is to run: ocictl init This will generate a template specification for you which you can then fill in with your custom build specifications. Our specification docs outline in detail how to tailor your specification to your specific build.","title":"Generating Template Spec"},{"location":"quickstart/#running-a-build","text":"Once you have configured your build specification to your project you can conduct a build by running: ocictl build This will conduct a docker build be default with your given specification. By default your build context path will be treated as the current directory. If you want to run the build using buildah as the build tool, you can: In your specification, set the daemon field to false Run the following command instead: ocictl build --builder buildah","title":"Running a Build"},{"location":"quickstart/#pushing-your-built-image","text":"Once your image has been built you can very easily push it with the following command ocictl push","title":"Pushing your built image"},{"location":"commands/build/","text":"Build Builds an oci compliant image using either docker or buildah Synopsis This command runs an image build with the specification defined in your projects ocibuilder.yaml file. It can run a build in both docker and buildah varieties. Command ocictl build [flags] [...] Options -n, --name Specify the name of your build or defined in ocibuilder.yaml -p, --path Path to your ocibuilder.yaml or build.yaml. By default will look in the current working directory -b, --builder Choose either docker and buildah as the targetted image builder. By default the builder is docker. -d, --debug Turn on debug logging -o, --overlay Path to your overlay.yaml file Example ocictl build --path ./ocibuilder.yaml --overlay ./overlay.yaml or you can use shorthand options like this: ocictl build -p ./ocibuilder.yaml -o ./overlay.yaml","title":"Build"},{"location":"commands/build/#build","text":"Builds an oci compliant image using either docker or buildah","title":"Build"},{"location":"commands/build/#synopsis","text":"This command runs an image build with the specification defined in your projects ocibuilder.yaml file. It can run a build in both docker and buildah varieties.","title":"Synopsis"},{"location":"commands/build/#command","text":"ocictl build [flags] [...]","title":"Command"},{"location":"commands/build/#options","text":"-n, --name Specify the name of your build or defined in ocibuilder.yaml -p, --path Path to your ocibuilder.yaml or build.yaml. By default will look in the current working directory -b, --builder Choose either docker and buildah as the targetted image builder. By default the builder is docker. -d, --debug Turn on debug logging -o, --overlay Path to your overlay.yaml file","title":"Options"},{"location":"commands/build/#example","text":"ocictl build --path ./ocibuilder.yaml --overlay ./overlay.yaml or you can use shorthand options like this: ocictl build -p ./ocibuilder.yaml -o ./overlay.yaml","title":"Example"},{"location":"commands/init/","text":"Init Initialises your repository with a ocibuilder.yaml file Synopsis This command creates a very basic ocibuilder.yaml template file, allowing you to easily get up and running and start customising your build specification Command ocictl init [flags] [...] Options --dry Execute a dry run of init, outputting the spec.yml file to be generated to stdout -d, --debug Turn on debug logging Example Command ocictl init","title":"Init"},{"location":"commands/init/#init","text":"Initialises your repository with a ocibuilder.yaml file","title":"Init"},{"location":"commands/init/#synopsis","text":"This command creates a very basic ocibuilder.yaml template file, allowing you to easily get up and running and start customising your build specification","title":"Synopsis"},{"location":"commands/init/#command","text":"ocictl init [flags] [...]","title":"Command"},{"location":"commands/init/#options","text":"--dry Execute a dry run of init, outputting the spec.yml file to be generated to stdout -d, --debug Turn on debug logging","title":"Options"},{"location":"commands/init/#example","text":"Command ocictl init","title":"Example"},{"location":"commands/login/","text":"Login Logs into all registries defined in the specifcation. NOTE: Login functionality with the docker flavour of the builder does not currently maintain logged in sessions. This will be resolved in a future release. Synopsis This command logs into all registries that have been defined in the specification. You can login with a number of different credentials. These can be plain, taken from environment variables or kubernetes secrets. Command ocictl login [flags] [...] Options -p, --path Path to your ocibuilder.yaml or login.yaml. By default will look in the current working directory -b, --builder Choose either docker and buildah as the targetted image puller. By default the builder is docker. -d, --debug Turn on debug logging Example Command ocictl login --path ./ocibuilder.yaml","title":"Login"},{"location":"commands/login/#login","text":"Logs into all registries defined in the specifcation. NOTE: Login functionality with the docker flavour of the builder does not currently maintain logged in sessions. This will be resolved in a future release.","title":"Login"},{"location":"commands/login/#synopsis","text":"This command logs into all registries that have been defined in the specification. You can login with a number of different credentials. These can be plain, taken from environment variables or kubernetes secrets.","title":"Synopsis"},{"location":"commands/login/#command","text":"ocictl login [flags] [...]","title":"Command"},{"location":"commands/login/#options","text":"-p, --path Path to your ocibuilder.yaml or login.yaml. By default will look in the current working directory -b, --builder Choose either docker and buildah as the targetted image puller. By default the builder is docker. -d, --debug Turn on debug logging","title":"Options"},{"location":"commands/login/#example","text":"Command ocictl login --path ./ocibuilder.yaml","title":"Example"},{"location":"commands/pull/","text":"Pull Pulls an image passed with the name flag. Synopsis This command pulls an image that you have passed in by name. The name should include the path to the image but not the image registry itself. e.g. myimage/cool-image:0.0.1 The pull command looks to pull from any registries that have been specified in the login specification. Once the image has been found in any of the specified registries, a pull is executed. Command ocictl pull [flags] [...] Options -i, --name Specify the name of the image you want to pull -p, --path Path to your ocibuilder.yaml. By default will look in the current working directory -b, --builder Choose either docker and buildah as the targetted image puller. By default the builder is docker. -d, --debug Turn on debug logging Example Command ocictl pull --path ./ocibuilder.yaml --name myimage/cool-image:0.0.1","title":"Pull"},{"location":"commands/pull/#pull","text":"Pulls an image passed with the name flag.","title":"Pull"},{"location":"commands/pull/#synopsis","text":"This command pulls an image that you have passed in by name. The name should include the path to the image but not the image registry itself. e.g. myimage/cool-image:0.0.1 The pull command looks to pull from any registries that have been specified in the login specification. Once the image has been found in any of the specified registries, a pull is executed.","title":"Synopsis"},{"location":"commands/pull/#command","text":"ocictl pull [flags] [...]","title":"Command"},{"location":"commands/pull/#options","text":"-i, --name Specify the name of the image you want to pull -p, --path Path to your ocibuilder.yaml. By default will look in the current working directory -b, --builder Choose either docker and buildah as the targetted image puller. By default the builder is docker. -d, --debug Turn on debug logging","title":"Options"},{"location":"commands/pull/#example","text":"Command ocictl pull --path ./ocibuilder.yaml --name myimage/cool-image:0.0.1","title":"Example"},{"location":"commands/push/","text":"Push Pushes container images to one or multiple image registries. Synopsis This command pushes all specified images in the push specification to a corresponding registry. You can list many images to push and many registries. In order to complete a push to a repository, both the login and push specifications need to be filled in. A push is run with the authentication passed in the login spec. The registry, image and tag are used to create a full qualified image path e.g. my-image-registry.docker.com:1111/myimage/cool-image:0.0.1 Command ocictl push [flags] [...] Options -p, --path Path to your ocibuilder.yaml or push.yaml. By default will look in the current working directory -b, --builder Choose either docker and buildah as the targetted image builder. By default the builder is docker. -d, --debug Turn on debug logging Example ocibuilder.yaml push: - registry: my-image-registry.docker.com:1111 image: myimage/cool-image tag: 0.0.1 Command ocictl push --path ./ocibuilder.yaml or you can use shorthand option like this: ocictl push -p ./ocibuilder.yaml","title":"Push"},{"location":"commands/push/#push","text":"Pushes container images to one or multiple image registries.","title":"Push"},{"location":"commands/push/#synopsis","text":"This command pushes all specified images in the push specification to a corresponding registry. You can list many images to push and many registries. In order to complete a push to a repository, both the login and push specifications need to be filled in. A push is run with the authentication passed in the login spec. The registry, image and tag are used to create a full qualified image path e.g. my-image-registry.docker.com:1111/myimage/cool-image:0.0.1","title":"Synopsis"},{"location":"commands/push/#command","text":"ocictl push [flags] [...]","title":"Command"},{"location":"commands/push/#options","text":"-p, --path Path to your ocibuilder.yaml or push.yaml. By default will look in the current working directory -b, --builder Choose either docker and buildah as the targetted image builder. By default the builder is docker. -d, --debug Turn on debug logging","title":"Options"},{"location":"commands/push/#example","text":"ocibuilder.yaml push: - registry: my-image-registry.docker.com:1111 image: myimage/cool-image tag: 0.0.1 Command ocictl push --path ./ocibuilder.yaml or you can use shorthand option like this: ocictl push -p ./ocibuilder.yaml","title":"Example"},{"location":"examples/complete-spec/","text":"Complete Specification The below is a complete example of a ocibuilder.yaml file for the ocibuilder. # Sample complete ocibuilder.yaml # Build specification which defines our image build steps build: # Templates are reusable build templates which you can use at any build stage or step templates: # Name is the name of your build template which is referred to in a build stage - name: go-build-template # Cmd is any docker commands you wish to execute as part # of your container build, these can be docker commands or # or ansible commands cmd: - docker: # Inline accepts inline strings of docker commands, alternatively # you can pass a path of a file with docker # commands inline: - ADD . /src - RUN cd /src && go build -o goapp # Steps are all the individual build steps you want to execute, useful # if you want to run multiple builds with one # specification steps: # Metadata is where you define your final image build name as well as any labels - metadata: name: my-docker-registry:4555/art/go-service # Stages allow you to define any stages you want in your build stages: # First build stage - we are building with the golang:alpine base image, # using the go-build-template defined above, and naming our build stage # 'build-env' for use in further build stages - metadata: name: build-env base: image: golang platform: alpine template: go-build-template # Second build stage - we are building with an alpine base image and using # inline docker cmds without a template - metadata: name: alpine-stage base: image: alpine cmd: - docker: inline: - WORKDIR /app # We can refer to our previous stage here by it's name - COPY --from=build-env /src/goapp /app/ - ENTRYPOINT ./goapp # Tag is the tag of the final built image tag: v0.1.0 # Purge is whether we want the purge the image after it has been built purge: false # Login specification to define our registry logins and credentials. You can login # using an access token, plain # credentials or through credentials stored in environment variables login: # Registry is the specified registry to login to - registry: my-docker-registry:4555 # Token is your access token for the registry token: ThisIsMeloGinToken creds: plain: # Creds is the username or password (if no token) for the registry login username: art # Push specification to define which registry/registries we want to push to. This # example will ultimately push the image `my-docker-registry:4555/art/go-service:v0.1.0` # to my-docker-registry:4555 push: # Registry is the specified registry to push to, expected that a matching registry # is logged in to - registry: my-docker-registry:4555 # The image name to push (not including registry prefix) image: art/go-service # The tag of the image to push tag: v0.1.0","title":"Complete Specification"},{"location":"examples/complete-spec/#complete-specification","text":"The below is a complete example of a ocibuilder.yaml file for the ocibuilder. # Sample complete ocibuilder.yaml # Build specification which defines our image build steps build: # Templates are reusable build templates which you can use at any build stage or step templates: # Name is the name of your build template which is referred to in a build stage - name: go-build-template # Cmd is any docker commands you wish to execute as part # of your container build, these can be docker commands or # or ansible commands cmd: - docker: # Inline accepts inline strings of docker commands, alternatively # you can pass a path of a file with docker # commands inline: - ADD . /src - RUN cd /src && go build -o goapp # Steps are all the individual build steps you want to execute, useful # if you want to run multiple builds with one # specification steps: # Metadata is where you define your final image build name as well as any labels - metadata: name: my-docker-registry:4555/art/go-service # Stages allow you to define any stages you want in your build stages: # First build stage - we are building with the golang:alpine base image, # using the go-build-template defined above, and naming our build stage # 'build-env' for use in further build stages - metadata: name: build-env base: image: golang platform: alpine template: go-build-template # Second build stage - we are building with an alpine base image and using # inline docker cmds without a template - metadata: name: alpine-stage base: image: alpine cmd: - docker: inline: - WORKDIR /app # We can refer to our previous stage here by it's name - COPY --from=build-env /src/goapp /app/ - ENTRYPOINT ./goapp # Tag is the tag of the final built image tag: v0.1.0 # Purge is whether we want the purge the image after it has been built purge: false # Login specification to define our registry logins and credentials. You can login # using an access token, plain # credentials or through credentials stored in environment variables login: # Registry is the specified registry to login to - registry: my-docker-registry:4555 # Token is your access token for the registry token: ThisIsMeloGinToken creds: plain: # Creds is the username or password (if no token) for the registry login username: art # Push specification to define which registry/registries we want to push to. This # example will ultimately push the image `my-docker-registry:4555/art/go-service:v0.1.0` # to my-docker-registry:4555 push: # Registry is the specified registry to push to, expected that a matching registry # is logged in to - registry: my-docker-registry:4555 # The image name to push (not including registry prefix) image: art/go-service # The tag of the image to push tag: v0.1.0","title":"Complete Specification"},{"location":"examples/go-spec/","text":"Go Specification An example of a well commented specification for a multi-stage build for a standard Go project. build: templates: - name: template-1 cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp - name: template-2 cmd: - docker: inline: - WORKDIR /app - COPY --from=build-env /src/goapp /app/ - ENTRYPOINT ./goapp steps: - metadata: name: docker.io/example-repo/go-service labels: type: build-1 overlay: first-step stages: - metadata: name: build-env base: image: golang platform: alpine template: template-1 - metadata: name: alpine-stage base: image: alpine template: template-2 tag: v0.1.0 purge: false context: localContext: contextPath: . login: - registry: docker.io token: REPLACED_BY_PARAM creds: plain: username: REPLACED_BY_PARAM push: - registry: docker.io image: example-repo/go-service tag: v0.1.0 params: - dest: login.0.token valueFromEnvVariable: DOCKERHUB_TOKEN - dest: login.0.creds.plain.username valueFromEnvVariable: DOCKERHUB_USER","title":"Go Specification"},{"location":"examples/go-spec/#go-specification","text":"An example of a well commented specification for a multi-stage build for a standard Go project. build: templates: - name: template-1 cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp - name: template-2 cmd: - docker: inline: - WORKDIR /app - COPY --from=build-env /src/goapp /app/ - ENTRYPOINT ./goapp steps: - metadata: name: docker.io/example-repo/go-service labels: type: build-1 overlay: first-step stages: - metadata: name: build-env base: image: golang platform: alpine template: template-1 - metadata: name: alpine-stage base: image: alpine template: template-2 tag: v0.1.0 purge: false context: localContext: contextPath: . login: - registry: docker.io token: REPLACED_BY_PARAM creds: plain: username: REPLACED_BY_PARAM push: - registry: docker.io image: example-repo/go-service tag: v0.1.0 params: - dest: login.0.token valueFromEnvVariable: DOCKERHUB_TOKEN - dest: login.0.creds.plain.username valueFromEnvVariable: DOCKERHUB_USER","title":"Go Specification"},{"location":"examples/java-spec/","text":"Java Specification An example of a well commented specification for a multi-stage build for a standard Java war. build: templates: - name: template-1 cmd: - docker: inline: # copy WAR into image - COPY spring-boot-app-0.0.1-SNAPSHOT.war /app.war # run application with this command line - CMD [\"/usr/bin/java\", \"-jar\", \"-Dspring.profiles.active=default\", \"/app.war\"] steps: - metadata: name: docker.io/example-repo/java-proj stages: - metadata: name: build-env base: image: openjdk tag: 8-jre-alpine template: template-1 tag: v0.1.0 purge: false context: localContext: contextPath: . login: - registry: docker.io token: REPLACED_BY_PARAM creds: plain: username: REPLACED_BY_PARAM push: - registry: docker.io image: example-repo/java-proj tag: v0.1.0 params: - dest: login.0.token valueFromEnvVariable: DOCKERHUB_TOKEN - dest: login.0.creds.plain.username valueFromEnvVariable: DOCKERHUB_USER","title":"Java Specification"},{"location":"examples/java-spec/#java-specification","text":"An example of a well commented specification for a multi-stage build for a standard Java war. build: templates: - name: template-1 cmd: - docker: inline: # copy WAR into image - COPY spring-boot-app-0.0.1-SNAPSHOT.war /app.war # run application with this command line - CMD [\"/usr/bin/java\", \"-jar\", \"-Dspring.profiles.active=default\", \"/app.war\"] steps: - metadata: name: docker.io/example-repo/java-proj stages: - metadata: name: build-env base: image: openjdk tag: 8-jre-alpine template: template-1 tag: v0.1.0 purge: false context: localContext: contextPath: . login: - registry: docker.io token: REPLACED_BY_PARAM creds: plain: username: REPLACED_BY_PARAM push: - registry: docker.io image: example-repo/java-proj tag: v0.1.0 params: - dest: login.0.token valueFromEnvVariable: DOCKERHUB_TOKEN - dest: login.0.creds.plain.username valueFromEnvVariable: DOCKERHUB_USER","title":"Java Specification"},{"location":"examples/simple-build-spec/","text":"Simple Build An example of a simple build specification, which can be used as a build.yaml file or configured within your ocibuilder.yaml . # You can either use this individual build.yaml file or # specify the build specifications in the global ocibuilder.yaml builds: templates: - name: template-1 cmd: - docker: inline: - RUN pip install kubernetes - COPY app/ /bin/app steps: - metadata: name: name-of-the-build labels: type: build-1 stages: - metadata: name: name-of-the-stage base: image: python tag: 3 template: template-1 tag: v0.1.0 purge: true daemon: true","title":"Simple Build"},{"location":"examples/simple-build-spec/#simple-build","text":"An example of a simple build specification, which can be used as a build.yaml file or configured within your ocibuilder.yaml . # You can either use this individual build.yaml file or # specify the build specifications in the global ocibuilder.yaml builds: templates: - name: template-1 cmd: - docker: inline: - RUN pip install kubernetes - COPY app/ /bin/app steps: - metadata: name: name-of-the-build labels: type: build-1 stages: - metadata: name: name-of-the-stage base: image: python tag: 3 template: template-1 tag: v0.1.0 purge: true daemon: true","title":"Simple Build"},{"location":"examples/simple-login-spec/","text":"Simple Login An example of a simple login specification, which can be used as a login.yaml file or configured within your ocibuilder.yaml . # You can either use this individual login.yaml file or # specify the login specifications in the global ocibuilder.yaml # login into different docker registries login: - registry: test-registry creds: plain: username: cool-username password: top-secret-password - registry: url-of-the-registry creds: env: username: $COOL_USERNAME password: $TOP_SECRET_PASSWORD","title":"Simple Login"},{"location":"examples/simple-login-spec/#simple-login","text":"An example of a simple login specification, which can be used as a login.yaml file or configured within your ocibuilder.yaml . # You can either use this individual login.yaml file or # specify the login specifications in the global ocibuilder.yaml # login into different docker registries login: - registry: test-registry creds: plain: username: cool-username password: top-secret-password - registry: url-of-the-registry creds: env: username: $COOL_USERNAME password: $TOP_SECRET_PASSWORD","title":"Simple Login"},{"location":"examples/simple-push-spec/","text":"Simple Push An example of a simple push specification, which can be used as a push.yaml file or configured within your ocibuilder.yaml . # You can either use this individual push.yaml file or # specify the push specifications in the global ocibuilder.yaml # This will push your images to specified registries push: - registry: abc.com image: my-awesome-build-ubuntu-xenial tag: v0.1.0 login: inline: username: cool-username password: top-secret-password - registry: abc.com user: art image: my-awesome-build-2-ubuntu-xenial tag: v0.1.0 login: env: username: $COOL_USERNAME password: $TOP_SECRET_PASSWORD","title":"Simple Push"},{"location":"examples/simple-push-spec/#simple-push","text":"An example of a simple push specification, which can be used as a push.yaml file or configured within your ocibuilder.yaml . # You can either use this individual push.yaml file or # specify the push specifications in the global ocibuilder.yaml # This will push your images to specified registries push: - registry: abc.com image: my-awesome-build-ubuntu-xenial tag: v0.1.0 login: inline: username: cool-username password: top-secret-password - registry: abc.com user: art image: my-awesome-build-2-ubuntu-xenial tag: v0.1.0 login: env: username: $COOL_USERNAME password: $TOP_SECRET_PASSWORD","title":"Simple Push"},{"location":"features/environment-variables/","text":"Environment Variables Description The ocibuilder supports two ways of parametizing your specification file. This is either through values specified in your ocibuilder.yaml directly or through referring to a system environment variable. Parameters are defined in the params field in your ocibuilder.yaml and refer to a destination of field to replace and the value you want the field to replaced with. NOTE : A specific array item is referred to by index in the dest field. For example, if you want to access the first step element you would have steps.0 Examples params: # Replaces the value in location build.steps.0.tag with 0.0.3 - dest: build.steps.0.tag value: 0.0.3 # Replaces the value in location build.steps.0.metadata.name with # the environment variable $BUILD_DEV - dest: build.steps.0.metadata.name valueFromEnvVariable: BUILD_DEV If you specify a valueFromEnvVariable with a value that has not been set, a warning will be returned stating that your environment variable is empty.","title":"Environment variables"},{"location":"features/environment-variables/#environment-variables","text":"","title":"Environment Variables"},{"location":"features/environment-variables/#description","text":"The ocibuilder supports two ways of parametizing your specification file. This is either through values specified in your ocibuilder.yaml directly or through referring to a system environment variable. Parameters are defined in the params field in your ocibuilder.yaml and refer to a destination of field to replace and the value you want the field to replaced with. NOTE : A specific array item is referred to by index in the dest field. For example, if you want to access the first step element you would have steps.0","title":"Description"},{"location":"features/environment-variables/#examples","text":"params: # Replaces the value in location build.steps.0.tag with 0.0.3 - dest: build.steps.0.tag value: 0.0.3 # Replaces the value in location build.steps.0.metadata.name with # the environment variable $BUILD_DEV - dest: build.steps.0.metadata.name valueFromEnvVariable: BUILD_DEV If you specify a valueFromEnvVariable with a value that has not been set, a warning will be returned stating that your environment variable is empty.","title":"Examples"},{"location":"features/metadata-store/","text":"Metadata Store One of the defining features of the ocibuilder is it's ability to automatically push build and image metadata to a Grafeas metadata store. To get started using Grafeas there is a getting started guide available here which goes through the definition and creation of Notes and Occurrences. The ocibuilder supports the storing of three difference types of metadata (or three different note types), and automatically generates occurrences for these types that you have available in your store. Metadata Types Attestation Image attestation helps to enable the binary authorization of container images. An attestation is a statement by an attestor that a required process in your pipeline has been completed and that a container image is authorized for deployment. The ocibuilder automatically signs the image with a given (GPG) ASCII armored private key and pushes the image signature to Grafeas when enabled. NOTE : In order to sign an image you MUST provide a private and public key or environment variables which refer to a public and private key. NOTE : The ocibuilder produces a signature using GPG from a GPG private and public key which are passed in. Ensure that your keys have been ASCII armored. This then gives you a fine grain control on what images can be pushed to production registries. For example by integrating a policy manager like OPA to ensure only images signed by a specific authority can be pushed to a production image registry. Below is an example attestation occurrence generated by ocibuilder: { \"name\": \"projects/image-build/occurrences/<UUID>\", \"resource\": { \"name\": \"\", \"uri\": \"docker.io/ocibuildere2e/go-test-service@sha256:imageID\", \"contentHash\": null }, \"noteName\": \"projects/image-build/notes/oci-attest\", \"kind\": \"NOTE_KIND_UNSPECIFIED\", \"remediation\": \"\", \"createTime\": \"2020-01-29T11:23:05.407978900Z\", \"updateTime\": \"2020-01-29T11:23:05.407978900Z\", \"attestation\": { \"attestation\": { \"pgpSignedAttestation\": { \"signature\": \"-----BEGIN PGP SIGNATURE-----\\n<MY_PGP_SIGNATURE>\\n-----END PGP SIGNATURE-----\", \"contentType\": \"CONTENT_TYPE_UNSPECIFIED\", \"pgpKeyId\": \"4RANDOMCHARACTERS\" } } } } Derived Image The derived image metadata stores image related metadata for the image that has just been built by the ocibuilder. This includes a number of useful auditable fields and includes metadata such as the image fingerprint (for both V1 and V2 docker registries), a breakdown of layer information, commands and arguments and finally the resource URI in the form <IMAGE_NAME>@<IMAGE_ID> . Below is an example of a derived image occurrence generated by ocibuilder: { \"name\": \"projects/image-build/occurrences/<UUID>\", \"resource\": { \"name\": \"\", \"uri\": \"docker.io/ocibuildere2e/go-test-service@sha256:<IMAGE_ID>\", \"contentHash\": null }, \"noteName\": \"projects/image-build/notes/oci-image\", \"kind\": \"NOTE_KIND_UNSPECIFIED\", \"remediation\": \"\", \"createTime\": \"2020-01-29T11:23:05.407903200Z\", \"updateTime\": \"2020-01-29T11:23:05.407903200Z\", \"derivedImage\": { \"derivedImage\": { \"fingerprint\": { \"v1Name\": \"sha256:<IMAGE_ID>\", \"v2Blob\": [ \"sha256:<LAYER_ID_SHA>\", \"sha256:<LAYER_ID_SHA>\", \"sha256:<LAYER_ID_SHA>\", \"sha256:<LAYER_ID_SHA>\", \"sha256:<LAYER_ID_SHA>\", \"sha256:<LAYER_ID_SHA>\", ], \"v2Name\": \"\" }, \"distance\": 0, \"layerInfo\": [ { \"directive\": \"LABEL\", \"arguments\": \"type=build-1\" }, { \"directive\": \"LABEL\", \"arguments\": \"overlay=first-step\" }, { \"directive\": \"ENTRYPOINT\", \"arguments\": \"[\\\"/bin/sh\\\" \\\"-c\\\" \\\"./goapp\\\"]\" }, { \"directive\": \"WORKDIR\", \"arguments\": \"/app\" }, { \"directive\": \"CMD\", \"arguments\": \"[\\\"/bin/sh\\\"]\" }, ], \"baseResourceUrl\": \"\" } } } Build The build metadata type stores build time related image metadata such as the creator, source code URI, ImageID, name as well as provenance and build timings. This allows you to easily compare build times, diagnose issues as well as have an accurate record of what image was built and when. Below is an example of a build occurrence generated by ocibuilder: { \"name\": \"projects/image-build/occurrences/<UUID>\", \"resource\": { \"name\": \"\", \"uri\": \"docker.io/ocibuildere2e/go-test-service@sha256:<IMAGE_ID>\", \"contentHash\": null }, \"noteName\": \"projects/image-build/notes/oci-build\", \"kind\": \"NOTE_KIND_UNSPECIFIED\", \"remediation\": \"\", \"createTime\": \"2020-01-29T11:23:05.407951300Z\", \"updateTime\": \"2020-01-29T11:23:05.407951300Z\", \"build\": { \"provenance\": { \"id\": \"<UUID>\", \"projectId\": \"image-build\", \"commands\": [], \"builtArtifacts\": [ { \"checksum\": \"sha256:<IMAGE_ID>\", \"id\": \"docker.io/ocibuildere2e/go-test-service@sha256:<IMAGE_ID>\", \"names\": [ \"docker.io/ocibuildere2e/go-test-service:v0.1.0\" ] } ], \"createTime\": \"2020-01-29T11:23:05.353335Z\", \"startTime\": \"2020-01-29T11:23:05.190303Z\", \"endTime\": \"2020-01-29T11:23:05.353335Z\", \"creator\": \"\", \"logsUri\": \"\", \"sourceProvenance\": { \"artifactStorageSourceUri\": \"\", \"fileHashes\": {}, \"context\": null, \"additionalContexts\": [] }, \"triggerId\": \"\", \"buildOptions\": {}, \"builderVersion\": \"\" }, \"provenanceBytes\": \"\" } Getting Started To get started pushing metadata to Grafeas, you need to ensure the follow: * You have an instance of Grafeas running that is accessible * You have created and pushed any relevant Notes to Grafeas that you want to generate your occurrences for. You can then update your ocibuilder.yaml configuration file to include the metadata field. Here you can list the metadata types that you'd like to push under the data array and also specify the note names that you had previously generated. Below is an example metadata specification. Please view the specification doc for more details. e.g. metadata: hostname: \"http://localhost:8080\" signKey: envPublicKey: OCI_PUB_KEY envPrivateKey: OCI_PRI_KEY storeConfig: grafeas: project: \"image-build\" notes: build: \"projects/image-build/notes/oci-build\" attestation: \"projects/image-build/notes/oci-attest\" image: \"projects/image-build/notes/oci-image\" data: - image - build - attestation","title":"Metadata Store"},{"location":"features/metadata-store/#metadata-store","text":"One of the defining features of the ocibuilder is it's ability to automatically push build and image metadata to a Grafeas metadata store. To get started using Grafeas there is a getting started guide available here which goes through the definition and creation of Notes and Occurrences. The ocibuilder supports the storing of three difference types of metadata (or three different note types), and automatically generates occurrences for these types that you have available in your store.","title":"Metadata Store"},{"location":"features/metadata-store/#metadata-types","text":"","title":"Metadata Types"},{"location":"features/metadata-store/#attestation","text":"Image attestation helps to enable the binary authorization of container images. An attestation is a statement by an attestor that a required process in your pipeline has been completed and that a container image is authorized for deployment. The ocibuilder automatically signs the image with a given (GPG) ASCII armored private key and pushes the image signature to Grafeas when enabled. NOTE : In order to sign an image you MUST provide a private and public key or environment variables which refer to a public and private key. NOTE : The ocibuilder produces a signature using GPG from a GPG private and public key which are passed in. Ensure that your keys have been ASCII armored. This then gives you a fine grain control on what images can be pushed to production registries. For example by integrating a policy manager like OPA to ensure only images signed by a specific authority can be pushed to a production image registry. Below is an example attestation occurrence generated by ocibuilder: { \"name\": \"projects/image-build/occurrences/<UUID>\", \"resource\": { \"name\": \"\", \"uri\": \"docker.io/ocibuildere2e/go-test-service@sha256:imageID\", \"contentHash\": null }, \"noteName\": \"projects/image-build/notes/oci-attest\", \"kind\": \"NOTE_KIND_UNSPECIFIED\", \"remediation\": \"\", \"createTime\": \"2020-01-29T11:23:05.407978900Z\", \"updateTime\": \"2020-01-29T11:23:05.407978900Z\", \"attestation\": { \"attestation\": { \"pgpSignedAttestation\": { \"signature\": \"-----BEGIN PGP SIGNATURE-----\\n<MY_PGP_SIGNATURE>\\n-----END PGP SIGNATURE-----\", \"contentType\": \"CONTENT_TYPE_UNSPECIFIED\", \"pgpKeyId\": \"4RANDOMCHARACTERS\" } } } }","title":"Attestation"},{"location":"features/metadata-store/#derived-image","text":"The derived image metadata stores image related metadata for the image that has just been built by the ocibuilder. This includes a number of useful auditable fields and includes metadata such as the image fingerprint (for both V1 and V2 docker registries), a breakdown of layer information, commands and arguments and finally the resource URI in the form <IMAGE_NAME>@<IMAGE_ID> . Below is an example of a derived image occurrence generated by ocibuilder: { \"name\": \"projects/image-build/occurrences/<UUID>\", \"resource\": { \"name\": \"\", \"uri\": \"docker.io/ocibuildere2e/go-test-service@sha256:<IMAGE_ID>\", \"contentHash\": null }, \"noteName\": \"projects/image-build/notes/oci-image\", \"kind\": \"NOTE_KIND_UNSPECIFIED\", \"remediation\": \"\", \"createTime\": \"2020-01-29T11:23:05.407903200Z\", \"updateTime\": \"2020-01-29T11:23:05.407903200Z\", \"derivedImage\": { \"derivedImage\": { \"fingerprint\": { \"v1Name\": \"sha256:<IMAGE_ID>\", \"v2Blob\": [ \"sha256:<LAYER_ID_SHA>\", \"sha256:<LAYER_ID_SHA>\", \"sha256:<LAYER_ID_SHA>\", \"sha256:<LAYER_ID_SHA>\", \"sha256:<LAYER_ID_SHA>\", \"sha256:<LAYER_ID_SHA>\", ], \"v2Name\": \"\" }, \"distance\": 0, \"layerInfo\": [ { \"directive\": \"LABEL\", \"arguments\": \"type=build-1\" }, { \"directive\": \"LABEL\", \"arguments\": \"overlay=first-step\" }, { \"directive\": \"ENTRYPOINT\", \"arguments\": \"[\\\"/bin/sh\\\" \\\"-c\\\" \\\"./goapp\\\"]\" }, { \"directive\": \"WORKDIR\", \"arguments\": \"/app\" }, { \"directive\": \"CMD\", \"arguments\": \"[\\\"/bin/sh\\\"]\" }, ], \"baseResourceUrl\": \"\" } } }","title":"Derived Image"},{"location":"features/metadata-store/#build","text":"The build metadata type stores build time related image metadata such as the creator, source code URI, ImageID, name as well as provenance and build timings. This allows you to easily compare build times, diagnose issues as well as have an accurate record of what image was built and when. Below is an example of a build occurrence generated by ocibuilder: { \"name\": \"projects/image-build/occurrences/<UUID>\", \"resource\": { \"name\": \"\", \"uri\": \"docker.io/ocibuildere2e/go-test-service@sha256:<IMAGE_ID>\", \"contentHash\": null }, \"noteName\": \"projects/image-build/notes/oci-build\", \"kind\": \"NOTE_KIND_UNSPECIFIED\", \"remediation\": \"\", \"createTime\": \"2020-01-29T11:23:05.407951300Z\", \"updateTime\": \"2020-01-29T11:23:05.407951300Z\", \"build\": { \"provenance\": { \"id\": \"<UUID>\", \"projectId\": \"image-build\", \"commands\": [], \"builtArtifacts\": [ { \"checksum\": \"sha256:<IMAGE_ID>\", \"id\": \"docker.io/ocibuildere2e/go-test-service@sha256:<IMAGE_ID>\", \"names\": [ \"docker.io/ocibuildere2e/go-test-service:v0.1.0\" ] } ], \"createTime\": \"2020-01-29T11:23:05.353335Z\", \"startTime\": \"2020-01-29T11:23:05.190303Z\", \"endTime\": \"2020-01-29T11:23:05.353335Z\", \"creator\": \"\", \"logsUri\": \"\", \"sourceProvenance\": { \"artifactStorageSourceUri\": \"\", \"fileHashes\": {}, \"context\": null, \"additionalContexts\": [] }, \"triggerId\": \"\", \"buildOptions\": {}, \"builderVersion\": \"\" }, \"provenanceBytes\": \"\" }","title":"Build"},{"location":"features/metadata-store/#getting-started","text":"To get started pushing metadata to Grafeas, you need to ensure the follow: * You have an instance of Grafeas running that is accessible * You have created and pushed any relevant Notes to Grafeas that you want to generate your occurrences for. You can then update your ocibuilder.yaml configuration file to include the metadata field. Here you can list the metadata types that you'd like to push under the data array and also specify the note names that you had previously generated. Below is an example metadata specification. Please view the specification doc for more details. e.g. metadata: hostname: \"http://localhost:8080\" signKey: envPublicKey: OCI_PUB_KEY envPrivateKey: OCI_PRI_KEY storeConfig: grafeas: project: \"image-build\" notes: build: \"projects/image-build/notes/oci-build\" attestation: \"projects/image-build/notes/oci-attest\" image: \"projects/image-build/notes/oci-image\" data: - image - build - attestation","title":"Getting Started"},{"location":"features/multi-stage-builds/","text":"Multi-Stage Builds Description Multi Stage builds were introduced in Docker 17.05, allowing you to optimize your image builds and share data between different builds. The ocibuilder allows you to easily define build stages in your specification in order to run a multi-stage build with either Docker or Buildah as the container builder. Defining a multi-stage build Multi-stage builds can defined at any build step. Each stage has a name defined under it's metadata field which can be referred to at any following build stage. For example a simple multi-stage go build can look as follows: steps: - metadata: name: artbegolli/go-service stages: - metadata: name: go-binary base: image: golang platform: alpine cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp - metadata: name: alpine-stage base: image: alpine cmd: - docker: inline: - WORKDIR /app - COPY --from=go-binary /src/goapp /app/ - ENTRYPOINT ./goapp The first stage of the build uses the golang:alpine base image to build our go binary and is named go-binary . Our second build stage refers to just our binary built in the first stage with --from=go-binary and copies this into our new container image and sets an entrypoint. This ultimately results in a significantly smaller image size by creating a minimal image which just contains our build artifcat. Future Enhancements Context labels defined for each stage Links Docker Multi-Stage Builds","title":"Multi stage builds"},{"location":"features/multi-stage-builds/#multi-stage-builds","text":"","title":"Multi-Stage Builds"},{"location":"features/multi-stage-builds/#description","text":"Multi Stage builds were introduced in Docker 17.05, allowing you to optimize your image builds and share data between different builds. The ocibuilder allows you to easily define build stages in your specification in order to run a multi-stage build with either Docker or Buildah as the container builder.","title":"Description"},{"location":"features/multi-stage-builds/#defining-a-multi-stage-build","text":"Multi-stage builds can defined at any build step. Each stage has a name defined under it's metadata field which can be referred to at any following build stage. For example a simple multi-stage go build can look as follows: steps: - metadata: name: artbegolli/go-service stages: - metadata: name: go-binary base: image: golang platform: alpine cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp - metadata: name: alpine-stage base: image: alpine cmd: - docker: inline: - WORKDIR /app - COPY --from=go-binary /src/goapp /app/ - ENTRYPOINT ./goapp The first stage of the build uses the golang:alpine base image to build our go binary and is named go-binary . Our second build stage refers to just our binary built in the first stage with --from=go-binary and copies this into our new container image and sets an entrypoint. This ultimately results in a significantly smaller image size by creating a minimal image which just contains our build artifcat.","title":"Defining a multi-stage build"},{"location":"features/multi-stage-builds/#future-enhancements","text":"Context labels defined for each stage","title":"Future Enhancements"},{"location":"features/multi-stage-builds/#links","text":"Docker Multi-Stage Builds","title":"Links"},{"location":"features/overlays/","text":"Overlays Description The ocibuilder supports yaml overlays which can be applied at runtime using the --overlay command line flag and passing in an overlay yaml file. The overlaying functionality of ocibuilder is built on top of ytt which makes use of annotations for matching and overlaying yaml on top of a template. The ocibuilder abstracts away these annotations and takes advantage of labels which can be defined in your build specification. You specify what array item you want to overlay by adding an overlay: <NAME> label to your specification file. The ocibuilder will then match this label with the same label in your overlay file and apply all the necessary annotations for you. NOTE: If you want to specify your own ytt annotations, you are able to do so by passing a standard annotated ytt overlay file . Annotation reference for ytt can be found here . Remote Overlays Remote overlays are also supported by the ocibuilder. To use a remote overlay, simple pass in a valid URL as your overlay path. This will then downloaded and the overlay will be applied to your specification. Your downloaded overlay file will then be cleaned up for you. e.g. ocictl build --overlay https://github.com/randomrepo/overlay.yaml Examples ocibuilder.yaml build: templates: - name: template-1 cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp steps: - metadata: name: go-build labels: overlay: first-step stages: - metadata: name: build-env base: image: golang platform: alpine template: template-1 tag: v0.1.0 overlay.yaml build: steps: - metadata: labels: # required overlay label to refer to specific build step overlay: first-step # the value which we want to override in our template tag: v0.2.0 overlay applied build: templates: - name: template-1 cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp steps: - metadata: name: go-build labels: overlay: first-step stages: - metadata: name: build-env base: image: golang platform: alpine template: template-1 # the new tag value which has been overlayed onto the spec tag: v0.2.0","title":"Overlays"},{"location":"features/overlays/#overlays","text":"","title":"Overlays"},{"location":"features/overlays/#description","text":"The ocibuilder supports yaml overlays which can be applied at runtime using the --overlay command line flag and passing in an overlay yaml file. The overlaying functionality of ocibuilder is built on top of ytt which makes use of annotations for matching and overlaying yaml on top of a template. The ocibuilder abstracts away these annotations and takes advantage of labels which can be defined in your build specification. You specify what array item you want to overlay by adding an overlay: <NAME> label to your specification file. The ocibuilder will then match this label with the same label in your overlay file and apply all the necessary annotations for you. NOTE: If you want to specify your own ytt annotations, you are able to do so by passing a standard annotated ytt overlay file . Annotation reference for ytt can be found here .","title":"Description"},{"location":"features/overlays/#remote-overlays","text":"Remote overlays are also supported by the ocibuilder. To use a remote overlay, simple pass in a valid URL as your overlay path. This will then downloaded and the overlay will be applied to your specification. Your downloaded overlay file will then be cleaned up for you. e.g. ocictl build --overlay https://github.com/randomrepo/overlay.yaml","title":"Remote Overlays"},{"location":"features/overlays/#examples","text":"ocibuilder.yaml build: templates: - name: template-1 cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp steps: - metadata: name: go-build labels: overlay: first-step stages: - metadata: name: build-env base: image: golang platform: alpine template: template-1 tag: v0.1.0 overlay.yaml build: steps: - metadata: labels: # required overlay label to refer to specific build step overlay: first-step # the value which we want to override in our template tag: v0.2.0 overlay applied build: templates: - name: template-1 cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp steps: - metadata: name: go-build labels: overlay: first-step stages: - metadata: name: build-env base: image: golang platform: alpine template: template-1 # the new tag value which has been overlayed onto the spec tag: v0.2.0","title":"Examples"},{"location":"specification/specification/","text":"Configuring Ocibuilder This document is a reference for ocibuilder v0.1.0 specification keys used in ocibuilder.yaml . You can find a complete ocibuilder.yaml example here . Table of Contents build templates name cmd ansible galaxy local docker steps context localContext gitContext stages cmd metadata base metadata login creds plain env push params daemon metadata storeConfig signKey grafeas notes data build A build comprises of reusable build templates and a number of build steps Name Type Description Required templates (Array) v1alpha1.BuildTemplate Templates are set of build templates that describe steps needed to build a Dockerfile No steps (Array) v1alpha1.BuildStep Individual build definitions to run Yes templates Templates are reusable build configurations that can be used accross a number of different build steps and are referred to by the name field. Multiple build commands can be entered which will be executed by ocibuilder. Name Type Description Required name string Name of the template Yes cmd (Array) v1alpha1.BuildTemplateStep Steps are instructions within a template to build a Dockerfile Yes Example templates: - name: go-build-template cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp The above example shows a very simple build template, using docker commands which have been passed inline. name Name is the name of the template. This can be referenced across multiple build steps and build stages allowing you to not have to rewrite standard build commands across different builds. cmd Cmd allows you to specify commands that you want to run in your build. This can be standard docker commands, which can be passed inline or through a file. Alternatively, you are able to specify an ansible step which you can use to point to a local ansible playbook or the name and requirements to pull from Ansible galaxy. Name Type Description Required ansible v1alpha1.AnsibleStep Ansible represents a ansible step within build template steps No docker v1alpha1.DockerStep Docker represents a docker step within build template steps No Example cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp - docker: path: ./docker-commands.txt - ansible: galaxy: name: my-ansible-role requirements: ./requirements.yaml local: playbook: ./playbook.yaml The above example shows all the possible flavours for inputting build commands into ocibuilder. ansible Ansible is used for entering references to local ansible playbooks or ansible roles in Ansible Galaxy. Each ansible step represents an ansible install as part of the build. Name Type Description Required galaxy v1alpha1.AnsibleGalaxy Galaxy contains information to install a ansible role through ansible-galaxy No local v1alpha1.AnsibleLocal Local contains information to install a ansible role through local playbook No galaxy AnsibleGalaxy contains ansible role information to be installed at the build Name Type Description Required name string Name of the galaxy role Yes requirements string Requirements refer to the requirements.yaml file No local AnsibleLocal contains information to install a ansible role through local playbook Name Type Description Required playbook string Playbook refers to playbook.yaml file Yes docker Docker is used for entering docker commands that you want to execute in your build. You have the option of passing commands inline with each docker command being a string array element. Alternatively, you can pass in a filepath to a text file which contains your docker commands. Name Type Description Required inline (Array) string Inline Dockerfile commands No path string Path to a file that contains Dockerfile commands No url string Url to a remote command file No auth v1alpha1.RemoteCreds Basic auth for accessing a remote file No auth You can specify remote basic auth credentials for accessing remote template files and overlays Name Type Description Required username string Username refers to an env var that holds the username Yes password string Password refers to an env var that holds the password No steps Build steps are used to configure multiple unique builds with a single spec.yml . This can be particularly useful when trying to build multiple modules or projects in a single repository, allowing you to reuse the templates that you have defined in the specification. Each step is run consecutively by ocibuilder with concurrent build steps running in a future version of ocibuilder - progress can be tracked here . Name Type Description Required purge boolean Purge after built. Defaults is false. No context v1alpha1.context Specify an image build context for the step No stages ( Array ) v1alpha1.Stage Stages of the build Yes tag string The tag of the built image No metadata v1alpha1.ImageMetadata Image metadata, name, labels, annotations and source No The purge flag allows you to purge your built images after they've been built. Ensures cleanup and is useful in build pipelines to prevent the constant persisting of images which will not be used. Example # Steps are all the individual build steps you want to execute steps: # Metadata is where you define your final image build name as well as any labels - metadata: name: my-docker-registry:4555/art/go-service stages: - metadata: name: build-env base: image: golang platform: alpine template: go-build-template tag: v0.1.0 purge: false context: localContext: contextPath: ./go-app context context enables you to specify a build context for each individual build step. For example, if you have multiple directories and each directory is a separate build step, you are able to specify a particular directory as the build context that step. Additionally, an upcoming version of ocibuilder will have support to set external build contexts of S3 buckets and Git paths. Name Type Description Required localContext context.LocalContext Local context contains local context information for a build No localContext LocalContext holds local context information for an image build Name Type Description Required contextPath string The path to your build context. Yes gitContext gitContext is the build context from git for an image build Name Type Description Required url string The path to your build context Yes username Credentials Username for authentication No password Credentials Password for authentication No sshKeyPath string The path to your ssh key No branch string Branch to pull your context resource from No tag string Tag to pull your context resource from No ref string Ref to use to pull trigger resource. Will result in a shallow clone and fetch No remote GitRemoteConfig Remote to manage set of tracked repositories. Defaults to \"origin\" No stages Ocibuilder supports docker multi-stage builds to help drastically reduce final image sizes. You are able to define a multi-stage build in each build step. In each stage you have the option to define build commands under the cmd field or pass in a previously specified build template. A stage also takes in a base image. Required to pass in either cmd or a build template. Name Type Description Required base v1alpha1.Base Refers to parent image for given build stage. Yes cmd ( Array ) v1alpha1.BuildTemplateStep Cmd refers to a template defined in a stage without a template. No template string Template refers to one of the build templates. No metadata v1alpha1.ImageMetadata Image metadata, name, labels, annotations and source No Example stages: - metadata: name: go-binary base: image: golang platform: alpine cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp - metadata: name: alpine-stage base: image: alpine cmd: - docker: inline: - WORKDIR /app - COPY --from=go-binary /src/goapp /app/ - ENTRYPOINT ./goapp In the above example, the first stage of the build uses the golang:alpine base image to build our go binary and is named go-binary . Our second build stage refers to just our binary built in the first stage with --from=go-binary and copies this into our new container image and sets an entrypoint. More details about multi-stage builds can be found here base Base is where you define your base image. Name Type Description Required image string The name of the image Yes platform string The specified platform of the image No tag string The tag for the image No Example base: image: golang platform: alpine tag: latest metadata [ image ] This is where any image metadata is defined, including image name, any labels and annotations that you want to specify for your build. The metadata type is used both in build steps and build stages. Within a build step name is used to name your final built image, but can be also used to refer to other build stages in a multi-stage build. Any labels specified in your build configuration will be attached to your built image. Name Type Description Required annotations map Annotations for your build config No labels map Labels for your build config and built image No name string Name for your build configuration Yes creator string Creator is the creator of the project Yes source string Source is the URI to the source code repository Yes login Login is used to specify credentials necessary to login to an image registry. These credentials are required to push and pull images from an image registry. You can specify credentials through plain, with environment variables, through the use of a token or a combination of the above. Params can also be used in conjunction with login credentials to pass in environment variables as a token or plaintext credentials. NOTE Using a token may also require you to pass in a username as a credential depending on your image registry. Name Type Description Required creds v1alpha1.RegistryCreds credentials required to log into the registry Yes registry string Registry refers to a OCI image registry Yes token string An image registry token No Example login: - registry: my-docker-registry:4555 token: ThisIsMeloGinToken creds: plain: username: art creds Holds the specific credentials to login to a given image registry Name Type Description Required env v1alpha1.EnvCreds Env refers to the credentials stored in environment variables No plain v1alpha1.PlainCreds Plain refers to the credentials set inline No env Credentials pulled from enviroment variables Name Type Description Required username string Username refers to an env var that holds the username Yes password string Password refers to an env var that holds the password Yes Example login: env: username: REGISTRY_USER password: REGISTRY_PASS plain Plaintext credentials for image registry login NOTE It is not recommended to store your credentials in plaintext Name Type Description Required username string Plaintext registry username Yes password string Plaintext registry password Yes Example login: env: username: artsuser password: artsp4ss push Push enables you to specify multiple registries to push your image to. Push expects the registry you want to push to have a corresponding login specification. Name Type Description Required image string Image to push Yes registry string Registry is the name of the registry Yes tag string Tag version of the image (e.g: v0.1.1) Yes Example push: - registry: my-docker-registry:4555 image: art/go-service tag: v0.1.0 params Params is where you can define parameters, allowing you to replace any value in the specification with a value or an environment variable. You specify the destination of the value you want to replace in the dest key using dot notation to access nested elements. NOTE : A specific array item is referred to by index in the dest field. For example, if you want to access the first step element you would have steps.0 Name Type Description Required dest string Dest is the destination of the field to replace with the parameter Yes value string Value of the environment variable. No valueFromEnvVariable string a variable which is to be replaced by an env var No Example params: # Replaces the value in location build.steps.0.tag with 0.0.3 - dest: build.steps.0.tag value: 0.0.3 # Replaces the value in location build.steps.0.metadata.name with the environment variable $BUILD_DEV - dest: build.steps.0.metadata.name valueFromEnvVariable: BUILD_DEV daemon Daemon is a boolean which allows you to specify whether you want to use the docker daemon, or buildah as an alternative. A true value will execute all commands using docker, a false flag will execute all commands using buildah. This value can be overriding by the builder command line flag which takes priority. Name Type Description Required daemon boolean Allows you to specify whether to use the docker daemon as a builder or buildah. Default is true. No metadata Metadata allows you to define all the configurations for pushing build and image metadata into a metadata store like Grafeas . Name Type Description Required storeConfig v1alpha1.StoreConfig StoreConfig holds the configuration for connecting to a metadata store No signKey *v1alpha1.SignKey SignKey holds the signing key for signing image IDs for image attestation purposes No hostname string Hostname is the hostname of your metadata store No data []v1alpha1.MetadataType Data holds a list of all the metadata types that you would like to push to your metadata store No Example metadata: hostname: \"http://localhost:8080\" signKey: envPublicKey: OCI_PUB_KEY envPrivateKey: OCI_PRI_KEY storeConfig: grafeas: project: \"image-build\" notes: build: \"projects/image-build/notes/oci-build\" attestation: \"projects/image-build/notes/oci-attest\" image: \"projects/image-build/notes/oci-image\" data: - image - build - attestation storeConfig Store config holds store specific configurations to do with connection and required fields. Currently the only metadata store support by the ocibuilder is Grafeas. Name Type Description Required grafeas *v1alpha1.Grafeas Grafeas holds the config for the Grafeas metadata store Yes grafeas Grafeas holds any grafeas specific configurations. This allows you to specify a project to push metadata to as well as define individual notes for each type of metadata that can be pushed. Name Type Description Required project string Project is the name of the project ID to store the occurrence Yes notes v1alpha1.Notes Notes holds the notes for each of the three occurrence types Yes notes Notes is where you can specify Grafeas note names for Build, Attestation and DerivedImage metadata. Name Type Description Required attestation string Attestation is the analysis note associated with a attestation occurrence, in the form of projects/[PROVIDER_ID]/notes/[NOTE_ID] Yes build string Build is the analysis note associated with a build occurrence, in the form of projects/[PROVIDER_ID]/notes/[NOTE_ID] Yes image string Image is the analysis note associated with a derived image occurrence, in the form of projects/[PROVIDER_ID]/notes/[NOTE_ID] Yes signKey SignKey holds your private and public signing keys to sign your image after it has been built which can be used later for image attestation. Name Type Description Required plainPrivateKey string PrivateKey is an ascii armored private key used to sign images for image attestation No plainPublicKey string PublicKey is the ascii armored public key for verification in image attestation No envPrivateKey string EnvPrivateKey is an env variable that holds an ascii armored private key used to sign images for image attestation No envPublicKey string EnvPublicKey is an env variable that holds an ascii armored public key used to sign images for image attestation No passphrase string Passphrase is the passphrase for decrypting the private key No data Data holds a list of the types of metadata that you want pushed to the Metadata store. Name Type Description Required attestation string Attestation in the data array signifies you want to store attestation metadata No build string Build in the data array signifies you want to store build metadata No image string Image in the data array signifies you want to store image metadata No","title":"Configuring Ocibuilder"},{"location":"specification/specification/#configuring-ocibuilder","text":"This document is a reference for ocibuilder v0.1.0 specification keys used in ocibuilder.yaml . You can find a complete ocibuilder.yaml example here .","title":"Configuring Ocibuilder"},{"location":"specification/specification/#table-of-contents","text":"build templates name cmd ansible galaxy local docker steps context localContext gitContext stages cmd metadata base metadata login creds plain env push params daemon metadata storeConfig signKey grafeas notes data","title":"Table of Contents"},{"location":"specification/specification/#build","text":"A build comprises of reusable build templates and a number of build steps Name Type Description Required templates (Array) v1alpha1.BuildTemplate Templates are set of build templates that describe steps needed to build a Dockerfile No steps (Array) v1alpha1.BuildStep Individual build definitions to run Yes","title":"build"},{"location":"specification/specification/#templates","text":"Templates are reusable build configurations that can be used accross a number of different build steps and are referred to by the name field. Multiple build commands can be entered which will be executed by ocibuilder. Name Type Description Required name string Name of the template Yes cmd (Array) v1alpha1.BuildTemplateStep Steps are instructions within a template to build a Dockerfile Yes Example templates: - name: go-build-template cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp The above example shows a very simple build template, using docker commands which have been passed inline.","title":"templates"},{"location":"specification/specification/#name","text":"Name is the name of the template. This can be referenced across multiple build steps and build stages allowing you to not have to rewrite standard build commands across different builds.","title":"name"},{"location":"specification/specification/#cmd","text":"Cmd allows you to specify commands that you want to run in your build. This can be standard docker commands, which can be passed inline or through a file. Alternatively, you are able to specify an ansible step which you can use to point to a local ansible playbook or the name and requirements to pull from Ansible galaxy. Name Type Description Required ansible v1alpha1.AnsibleStep Ansible represents a ansible step within build template steps No docker v1alpha1.DockerStep Docker represents a docker step within build template steps No Example cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp - docker: path: ./docker-commands.txt - ansible: galaxy: name: my-ansible-role requirements: ./requirements.yaml local: playbook: ./playbook.yaml The above example shows all the possible flavours for inputting build commands into ocibuilder.","title":"cmd"},{"location":"specification/specification/#ansible","text":"Ansible is used for entering references to local ansible playbooks or ansible roles in Ansible Galaxy. Each ansible step represents an ansible install as part of the build. Name Type Description Required galaxy v1alpha1.AnsibleGalaxy Galaxy contains information to install a ansible role through ansible-galaxy No local v1alpha1.AnsibleLocal Local contains information to install a ansible role through local playbook No","title":"ansible"},{"location":"specification/specification/#galaxy","text":"AnsibleGalaxy contains ansible role information to be installed at the build Name Type Description Required name string Name of the galaxy role Yes requirements string Requirements refer to the requirements.yaml file No","title":"galaxy"},{"location":"specification/specification/#local","text":"AnsibleLocal contains information to install a ansible role through local playbook Name Type Description Required playbook string Playbook refers to playbook.yaml file Yes","title":"local"},{"location":"specification/specification/#docker","text":"Docker is used for entering docker commands that you want to execute in your build. You have the option of passing commands inline with each docker command being a string array element. Alternatively, you can pass in a filepath to a text file which contains your docker commands. Name Type Description Required inline (Array) string Inline Dockerfile commands No path string Path to a file that contains Dockerfile commands No url string Url to a remote command file No auth v1alpha1.RemoteCreds Basic auth for accessing a remote file No","title":"docker"},{"location":"specification/specification/#auth","text":"You can specify remote basic auth credentials for accessing remote template files and overlays Name Type Description Required username string Username refers to an env var that holds the username Yes password string Password refers to an env var that holds the password No","title":"auth"},{"location":"specification/specification/#steps","text":"Build steps are used to configure multiple unique builds with a single spec.yml . This can be particularly useful when trying to build multiple modules or projects in a single repository, allowing you to reuse the templates that you have defined in the specification. Each step is run consecutively by ocibuilder with concurrent build steps running in a future version of ocibuilder - progress can be tracked here . Name Type Description Required purge boolean Purge after built. Defaults is false. No context v1alpha1.context Specify an image build context for the step No stages ( Array ) v1alpha1.Stage Stages of the build Yes tag string The tag of the built image No metadata v1alpha1.ImageMetadata Image metadata, name, labels, annotations and source No The purge flag allows you to purge your built images after they've been built. Ensures cleanup and is useful in build pipelines to prevent the constant persisting of images which will not be used. Example # Steps are all the individual build steps you want to execute steps: # Metadata is where you define your final image build name as well as any labels - metadata: name: my-docker-registry:4555/art/go-service stages: - metadata: name: build-env base: image: golang platform: alpine template: go-build-template tag: v0.1.0 purge: false context: localContext: contextPath: ./go-app","title":"steps"},{"location":"specification/specification/#context","text":"context enables you to specify a build context for each individual build step. For example, if you have multiple directories and each directory is a separate build step, you are able to specify a particular directory as the build context that step. Additionally, an upcoming version of ocibuilder will have support to set external build contexts of S3 buckets and Git paths. Name Type Description Required localContext context.LocalContext Local context contains local context information for a build No","title":"context"},{"location":"specification/specification/#localcontext","text":"LocalContext holds local context information for an image build Name Type Description Required contextPath string The path to your build context. Yes","title":"localContext"},{"location":"specification/specification/#gitcontext","text":"gitContext is the build context from git for an image build Name Type Description Required url string The path to your build context Yes username Credentials Username for authentication No password Credentials Password for authentication No sshKeyPath string The path to your ssh key No branch string Branch to pull your context resource from No tag string Tag to pull your context resource from No ref string Ref to use to pull trigger resource. Will result in a shallow clone and fetch No remote GitRemoteConfig Remote to manage set of tracked repositories. Defaults to \"origin\" No","title":"gitContext"},{"location":"specification/specification/#stages","text":"Ocibuilder supports docker multi-stage builds to help drastically reduce final image sizes. You are able to define a multi-stage build in each build step. In each stage you have the option to define build commands under the cmd field or pass in a previously specified build template. A stage also takes in a base image. Required to pass in either cmd or a build template. Name Type Description Required base v1alpha1.Base Refers to parent image for given build stage. Yes cmd ( Array ) v1alpha1.BuildTemplateStep Cmd refers to a template defined in a stage without a template. No template string Template refers to one of the build templates. No metadata v1alpha1.ImageMetadata Image metadata, name, labels, annotations and source No Example stages: - metadata: name: go-binary base: image: golang platform: alpine cmd: - docker: inline: - ADD . /src - RUN cd /src && go build -o goapp - metadata: name: alpine-stage base: image: alpine cmd: - docker: inline: - WORKDIR /app - COPY --from=go-binary /src/goapp /app/ - ENTRYPOINT ./goapp In the above example, the first stage of the build uses the golang:alpine base image to build our go binary and is named go-binary . Our second build stage refers to just our binary built in the first stage with --from=go-binary and copies this into our new container image and sets an entrypoint. More details about multi-stage builds can be found here","title":"stages"},{"location":"specification/specification/#base","text":"Base is where you define your base image. Name Type Description Required image string The name of the image Yes platform string The specified platform of the image No tag string The tag for the image No Example base: image: golang platform: alpine tag: latest","title":"base"},{"location":"specification/specification/#metadata-image","text":"This is where any image metadata is defined, including image name, any labels and annotations that you want to specify for your build. The metadata type is used both in build steps and build stages. Within a build step name is used to name your final built image, but can be also used to refer to other build stages in a multi-stage build. Any labels specified in your build configuration will be attached to your built image. Name Type Description Required annotations map Annotations for your build config No labels map Labels for your build config and built image No name string Name for your build configuration Yes creator string Creator is the creator of the project Yes source string Source is the URI to the source code repository Yes","title":"metadata [image]"},{"location":"specification/specification/#login","text":"Login is used to specify credentials necessary to login to an image registry. These credentials are required to push and pull images from an image registry. You can specify credentials through plain, with environment variables, through the use of a token or a combination of the above. Params can also be used in conjunction with login credentials to pass in environment variables as a token or plaintext credentials. NOTE Using a token may also require you to pass in a username as a credential depending on your image registry. Name Type Description Required creds v1alpha1.RegistryCreds credentials required to log into the registry Yes registry string Registry refers to a OCI image registry Yes token string An image registry token No Example login: - registry: my-docker-registry:4555 token: ThisIsMeloGinToken creds: plain: username: art","title":"login"},{"location":"specification/specification/#creds","text":"Holds the specific credentials to login to a given image registry Name Type Description Required env v1alpha1.EnvCreds Env refers to the credentials stored in environment variables No plain v1alpha1.PlainCreds Plain refers to the credentials set inline No","title":"creds"},{"location":"specification/specification/#env","text":"Credentials pulled from enviroment variables Name Type Description Required username string Username refers to an env var that holds the username Yes password string Password refers to an env var that holds the password Yes Example login: env: username: REGISTRY_USER password: REGISTRY_PASS","title":"env"},{"location":"specification/specification/#plain","text":"Plaintext credentials for image registry login NOTE It is not recommended to store your credentials in plaintext Name Type Description Required username string Plaintext registry username Yes password string Plaintext registry password Yes Example login: env: username: artsuser password: artsp4ss","title":"plain"},{"location":"specification/specification/#push","text":"Push enables you to specify multiple registries to push your image to. Push expects the registry you want to push to have a corresponding login specification. Name Type Description Required image string Image to push Yes registry string Registry is the name of the registry Yes tag string Tag version of the image (e.g: v0.1.1) Yes Example push: - registry: my-docker-registry:4555 image: art/go-service tag: v0.1.0","title":"push"},{"location":"specification/specification/#params","text":"Params is where you can define parameters, allowing you to replace any value in the specification with a value or an environment variable. You specify the destination of the value you want to replace in the dest key using dot notation to access nested elements. NOTE : A specific array item is referred to by index in the dest field. For example, if you want to access the first step element you would have steps.0 Name Type Description Required dest string Dest is the destination of the field to replace with the parameter Yes value string Value of the environment variable. No valueFromEnvVariable string a variable which is to be replaced by an env var No Example params: # Replaces the value in location build.steps.0.tag with 0.0.3 - dest: build.steps.0.tag value: 0.0.3 # Replaces the value in location build.steps.0.metadata.name with the environment variable $BUILD_DEV - dest: build.steps.0.metadata.name valueFromEnvVariable: BUILD_DEV","title":"params"},{"location":"specification/specification/#daemon","text":"Daemon is a boolean which allows you to specify whether you want to use the docker daemon, or buildah as an alternative. A true value will execute all commands using docker, a false flag will execute all commands using buildah. This value can be overriding by the builder command line flag which takes priority. Name Type Description Required daemon boolean Allows you to specify whether to use the docker daemon as a builder or buildah. Default is true. No","title":"daemon"},{"location":"specification/specification/#metadata","text":"Metadata allows you to define all the configurations for pushing build and image metadata into a metadata store like Grafeas . Name Type Description Required storeConfig v1alpha1.StoreConfig StoreConfig holds the configuration for connecting to a metadata store No signKey *v1alpha1.SignKey SignKey holds the signing key for signing image IDs for image attestation purposes No hostname string Hostname is the hostname of your metadata store No data []v1alpha1.MetadataType Data holds a list of all the metadata types that you would like to push to your metadata store No Example metadata: hostname: \"http://localhost:8080\" signKey: envPublicKey: OCI_PUB_KEY envPrivateKey: OCI_PRI_KEY storeConfig: grafeas: project: \"image-build\" notes: build: \"projects/image-build/notes/oci-build\" attestation: \"projects/image-build/notes/oci-attest\" image: \"projects/image-build/notes/oci-image\" data: - image - build - attestation","title":"metadata"},{"location":"specification/specification/#storeconfig","text":"Store config holds store specific configurations to do with connection and required fields. Currently the only metadata store support by the ocibuilder is Grafeas. Name Type Description Required grafeas *v1alpha1.Grafeas Grafeas holds the config for the Grafeas metadata store Yes","title":"storeConfig"},{"location":"specification/specification/#grafeas","text":"Grafeas holds any grafeas specific configurations. This allows you to specify a project to push metadata to as well as define individual notes for each type of metadata that can be pushed. Name Type Description Required project string Project is the name of the project ID to store the occurrence Yes notes v1alpha1.Notes Notes holds the notes for each of the three occurrence types Yes","title":"grafeas"},{"location":"specification/specification/#notes","text":"Notes is where you can specify Grafeas note names for Build, Attestation and DerivedImage metadata. Name Type Description Required attestation string Attestation is the analysis note associated with a attestation occurrence, in the form of projects/[PROVIDER_ID]/notes/[NOTE_ID] Yes build string Build is the analysis note associated with a build occurrence, in the form of projects/[PROVIDER_ID]/notes/[NOTE_ID] Yes image string Image is the analysis note associated with a derived image occurrence, in the form of projects/[PROVIDER_ID]/notes/[NOTE_ID] Yes","title":"notes"},{"location":"specification/specification/#signkey","text":"SignKey holds your private and public signing keys to sign your image after it has been built which can be used later for image attestation. Name Type Description Required plainPrivateKey string PrivateKey is an ascii armored private key used to sign images for image attestation No plainPublicKey string PublicKey is the ascii armored public key for verification in image attestation No envPrivateKey string EnvPrivateKey is an env variable that holds an ascii armored private key used to sign images for image attestation No envPublicKey string EnvPublicKey is an env variable that holds an ascii armored public key used to sign images for image attestation No passphrase string Passphrase is the passphrase for decrypting the private key No","title":"signKey"},{"location":"specification/specification/#data","text":"Data holds a list of the types of metadata that you want pushed to the Metadata store. Name Type Description Required attestation string Attestation in the data array signifies you want to store attestation metadata No build string Build in the data array signifies you want to store build metadata No image string Image in the data array signifies you want to store image metadata No","title":"data"}]}